import{S as mt,i as dt,s as ft,y as p,a as m,k as n,q as a,z as $,c as d,l as i,m as s,r as l,h as o,n as u,A as g,b as c,G as t,H as pt,g as h,d as y,B as b}from"../chunks/index.a7566c1a.js";import{H as Y}from"../chunks/HeadingLink.20322812.js";import{C as te}from"../chunks/CodeBlock.a090ee9b.js";import{T as $t}from"../chunks/Toc.c31a36b6.js";function gt(ct){let w,re,P,oe,f,C,ve,O,z,we,_e,Ae,De,A,W,Ee,xe,Te,Be,U,Pe,Ce,J,Oe,Re,ae,R,le,S,ne,_,j,K,Se,D,k,qe,V,Ie,Me,X,Fe,Le,Z,Qe,He,Ne,E,We,x,je,Ve,ie,v,Ge,ee,Ye,ze,T,Ue,Je,se,q,ue,I,ce,M,me,F,de,L,fe,Q,pe,H,$e,N,ge;return w=new $t({}),P=new Y({props:{title:"Custom model struct"}}),R=new te({props:{language:"go",content:`
        // article.go
        package main

        import (
            "github.com/pocketbase/pocketbase/models"
            "github.com/pocketbase/pocketbase/tools/types"
        )

        // ensures that the Article struct satisfy the models.Model interface
        var _ models.Model = (*Article)(nil)

        type Article struct {
            models.BaseModel

            Title       string         \`db:"title" json:"title"\`
            Slug        string         \`db:"slug" json:"slug"\`
            Description string         \`db:"description" json:"description"\`
            Published   types.DateTime \`db:"published" json:"published"\`
        }

        func (m *Article) TableName() string {
            return "articles" // the name of your collection
        }
    `}}),S=new Y({props:{title:"Working with the custom model struct"}}),q=new Y({props:{title:"Fetch articles",tag:"h5"}}),I=new te({props:{language:"go",content:`
        // article_query.go
        package main

        import (
            "strings"

            "github.com/pocketbase/dbx"
            "github.com/pocketbase/pocketbase/daos"
        )

        func ArticleQuery(dao *daos.Dao) *dbx.SelectQuery {
            return dao.ModelQuery(&Article{})
        }

        func FindArticleById(dao *daos.Dao, id string) (*Article, error) {
            article := &Article{}

            err := ArticleQuery(dao).
                AndWhere(dbx.HashExp{"id": id}).
                Limit(1).
                One(article)

            if err != nil {
                return nil, err
            }

            return article, nil
        }

        func FindArticleBySlug(dao *daos.Dao, slug string) (*Article, error) {
            article := &Article{}

            err := ArticleQuery(dao).
                // case insensitive match
                AndWhere(dbx.NewExp("LOWER(slug)={:slug}", dbx.Params{
                    "slug": strings.ToLower(slug),
                })).
                Limit(1).
                One(article)

            if err != nil {
                return nil, err
            }

            return article, nil
        }

        func FindLast10Articles(dao *daos.Dao, slug string) ([]*Article, error) {
            articles := []*Article{}

            err := ArticleQuery(dao).
                Limit(10).
                OrderBy("published desc").
                All(&articles)

            if err != nil {
                return nil, err
            }

            return articles, nil
        }
    `}}),M=new Y({props:{title:"Create article",tag:"h5"}}),F=new te({props:{language:"go",content:`
        article := &Article{
            Title: "Lorem ipsum",
            Slug: "lorem-ipsum",
        }

        // the id is autogenerated, but you can set a specific one if you want to:
        // article.SetId("...")

        if err := app.Dao().Save(article); err != nil {
            return err
        }
    `}}),L=new Y({props:{title:"Update article",tag:"h5"}}),Q=new te({props:{language:"go",content:`
        article, err := FindArticleBySlug(app.Dao(), "lorem-ipsum")
        if err != nil {
            return err
        }

        article.Description = "Hello World!"

        if err := app.Dao().Save(article); err != nil {
            return err
        }
    `}}),H=new Y({props:{title:"Delete article",tag:"h5"}}),N=new te({props:{language:"go",content:`
        // optionally wrap in a transaction
        err := app.Dao().RunInTransaction(func(txDao *daos.Dao) error {
            article, err := FindArticleBySlug(txDao, "lorem-ipsum")
            if err != nil {
                return err
            }

            return txDao.Delete(article);
        })
    `}}),{c(){p(w.$$.fragment),re=m(),p(P.$$.fragment),oe=m(),f=n("p"),C=n("strong"),ve=a("The available "),O=n("a"),z=n("code"),we=a("models.Record"),_e=a(" and its helpers"),Ae=a(`
        is usually the preferred way to interact with your data
    `),De=a(`, but in some cases you may want to query and update your data using a typed struct. You can
    define your own model structs by implementing the
    `),A=n("a"),W=n("code"),Ee=a("models.Model"),xe=a(`
    interface.
    `),Te=n("br"),Be=a(`
    To make it a little bit easier, PocketBase also comes with a `),U=n("code"),Pe=a("models.BaseModel"),Ce=a(` struct that you
    can embed in your model, leaving only the `),J=n("code"),Oe=a("TableName()"),Re=a(` method to be implemented (aka. your collection
    name). For example:`),ae=m(),p(R.$$.fragment),le=m(),p(S.$$.fragment),ne=m(),_=n("div"),j=n("div"),K=n("i"),Se=m(),D=n("div"),k=n("p"),qe=a(`Please note that the internal
            `),V=n("a"),Ie=a("Record API and other related hooks"),Me=a(`
            works only with the
            `),X=n("code"),Fe=a("models.Record"),Le=a(" and you'll have to manually convert the "),Z=n("code"),Qe=a("models.Record"),He=a(` to your
            custom struct if you want to use it inside the event hooks.`),Ne=m(),E=n("p"),We=a(`There are plans to improve this workflow in the future with codegeneration (see
            `),x=n("a"),je=a("Discussion#2697"),Ve=a(")."),ie=m(),v=n("p"),Ge=a('To query your custom "Article" model you can use the '),ee=n("code"),Ye=a("app.Dao()"),ze=a(` instance and its query builder
    (`),T=n("a"),Ue=a("dbx"),Je=a(")."),se=m(),p(q.$$.fragment),ue=m(),p(I.$$.fragment),ce=m(),p(M.$$.fragment),me=m(),p(F.$$.fragment),de=m(),p(L.$$.fragment),fe=m(),p(Q.$$.fragment),pe=m(),p(H.$$.fragment),$e=m(),p(N.$$.fragment),this.h()},l(e){$(w.$$.fragment,e),re=d(e),$(P.$$.fragment,e),oe=d(e),f=i(e,"P",{});var r=s(f);C=i(r,"STRONG",{});var he=s(C);ve=l(he,"The available "),O=i(he,"A",{href:!0});var Ke=s(O);z=i(Ke,"CODE",{});var Xe=s(z);we=l(Xe,"models.Record"),Xe.forEach(o),_e=l(Ke," and its helpers"),Ke.forEach(o),Ae=l(he,`
        is usually the preferred way to interact with your data
    `),he.forEach(o),De=l(r,`, but in some cases you may want to query and update your data using a typed struct. You can
    define your own model structs by implementing the
    `),A=i(r,"A",{href:!0,target:!0,rel:!0});var Ze=s(A);W=i(Ze,"CODE",{class:!0});var et=s(W);Ee=l(et,"models.Model"),et.forEach(o),Ze.forEach(o),xe=l(r,`
    interface.
    `),Te=i(r,"BR",{}),Be=l(r,`
    To make it a little bit easier, PocketBase also comes with a `),U=i(r,"CODE",{});var tt=s(U);Pe=l(tt,"models.BaseModel"),tt.forEach(o),Ce=l(r,` struct that you
    can embed in your model, leaving only the `),J=i(r,"CODE",{});var rt=s(J);Oe=l(rt,"TableName()"),rt.forEach(o),Re=l(r,` method to be implemented (aka. your collection
    name). For example:`),r.forEach(o),ae=d(e),$(R.$$.fragment,e),le=d(e),$(S.$$.fragment,e),ne=d(e),_=i(e,"DIV",{class:!0});var ye=s(_);j=i(ye,"DIV",{class:!0});var ot=s(j);K=i(ot,"I",{class:!0}),s(K).forEach(o),ot.forEach(o),Se=d(ye),D=i(ye,"DIV",{class:!0});var be=s(D);k=i(be,"P",{});var B=s(k);qe=l(B,`Please note that the internal
            `),V=i(B,"A",{href:!0});var at=s(V);Ie=l(at,"Record API and other related hooks"),at.forEach(o),Me=l(B,`
            works only with the
            `),X=i(B,"CODE",{});var lt=s(X);Fe=l(lt,"models.Record"),lt.forEach(o),Le=l(B," and you'll have to manually convert the "),Z=i(B,"CODE",{});var nt=s(Z);Qe=l(nt,"models.Record"),nt.forEach(o),He=l(B,` to your
            custom struct if you want to use it inside the event hooks.`),B.forEach(o),Ne=d(be),E=i(be,"P",{class:!0});var ke=s(E);We=l(ke,`There are plans to improve this workflow in the future with codegeneration (see
            `),x=i(ke,"A",{href:!0,target:!0,rel:!0});var it=s(x);je=l(it,"Discussion#2697"),it.forEach(o),Ve=l(ke,")."),ke.forEach(o),be.forEach(o),ye.forEach(o),ie=d(e),v=i(e,"P",{});var G=s(v);Ge=l(G,'To query your custom "Article" model you can use the '),ee=i(G,"CODE",{});var st=s(ee);Ye=l(st,"app.Dao()"),st.forEach(o),ze=l(G,` instance and its query builder
    (`),T=i(G,"A",{href:!0,target:!0,rel:!0});var ut=s(T);Ue=l(ut,"dbx"),ut.forEach(o),Je=l(G,")."),G.forEach(o),se=d(e),$(q.$$.fragment,e),ue=d(e),$(I.$$.fragment,e),ce=d(e),$(M.$$.fragment,e),me=d(e),$(F.$$.fragment,e),de=d(e),$(L.$$.fragment,e),fe=d(e),$(Q.$$.fragment,e),pe=d(e),$(H.$$.fragment,e),$e=d(e),$(N.$$.fragment,e),this.h()},h(){u(O,"href","/docs/go-records"),u(W,"class","link-primary"),u(A,"href","https://pkg.go.dev/github.com/pocketbase/pocketbase@v0.7.10/models#Model"),u(A,"target","_blank"),u(A,"rel","noopener noreferrer"),u(K,"class","ri-information-line"),u(j,"class","icon"),u(V,"href","/docs/go-event-hooks"),u(x,"href","https://github.com/pocketbase/pocketbase/discussions/2697#discussioncomment-6154067"),u(x,"target","_blank"),u(x,"rel","noopener noreferrer"),u(E,"class","txt-bold"),u(D,"class","content"),u(_,"class","alert alert-info m-t-sm"),u(T,"href","https://pkg.go.dev/github.com/pocketbase/dbx"),u(T,"target","_blank"),u(T,"rel","noopener noreferrer")},m(e,r){g(w,e,r),c(e,re,r),g(P,e,r),c(e,oe,r),c(e,f,r),t(f,C),t(C,ve),t(C,O),t(O,z),t(z,we),t(O,_e),t(C,Ae),t(f,De),t(f,A),t(A,W),t(W,Ee),t(f,xe),t(f,Te),t(f,Be),t(f,U),t(U,Pe),t(f,Ce),t(f,J),t(J,Oe),t(f,Re),c(e,ae,r),g(R,e,r),c(e,le,r),g(S,e,r),c(e,ne,r),c(e,_,r),t(_,j),t(j,K),t(_,Se),t(_,D),t(D,k),t(k,qe),t(k,V),t(V,Ie),t(k,Me),t(k,X),t(X,Fe),t(k,Le),t(k,Z),t(Z,Qe),t(k,He),t(D,Ne),t(D,E),t(E,We),t(E,x),t(x,je),t(E,Ve),c(e,ie,r),c(e,v,r),t(v,Ge),t(v,ee),t(ee,Ye),t(v,ze),t(v,T),t(T,Ue),t(v,Je),c(e,se,r),g(q,e,r),c(e,ue,r),g(I,e,r),c(e,ce,r),g(M,e,r),c(e,me,r),g(F,e,r),c(e,de,r),g(L,e,r),c(e,fe,r),g(Q,e,r),c(e,pe,r),g(H,e,r),c(e,$e,r),g(N,e,r),ge=!0},p:pt,i(e){ge||(h(w.$$.fragment,e),h(P.$$.fragment,e),h(R.$$.fragment,e),h(S.$$.fragment,e),h(q.$$.fragment,e),h(I.$$.fragment,e),h(M.$$.fragment,e),h(F.$$.fragment,e),h(L.$$.fragment,e),h(Q.$$.fragment,e),h(H.$$.fragment,e),h(N.$$.fragment,e),ge=!0)},o(e){y(w.$$.fragment,e),y(P.$$.fragment,e),y(R.$$.fragment,e),y(S.$$.fragment,e),y(q.$$.fragment,e),y(I.$$.fragment,e),y(M.$$.fragment,e),y(F.$$.fragment,e),y(L.$$.fragment,e),y(Q.$$.fragment,e),y(H.$$.fragment,e),y(N.$$.fragment,e),ge=!1},d(e){b(w,e),e&&o(re),b(P,e),e&&o(oe),e&&o(f),e&&o(ae),b(R,e),e&&o(le),b(S,e),e&&o(ne),e&&o(_),e&&o(ie),e&&o(v),e&&o(se),b(q,e),e&&o(ue),b(I,e),e&&o(ce),b(M,e),e&&o(me),b(F,e),e&&o(de),b(L,e),e&&o(fe),b(Q,e),e&&o(pe),b(H,e),e&&o($e),b(N,e)}}}class vt extends mt{constructor(w){super(),dt(this,w,null,gt,ft,{})}}export{vt as component};
