import{S as gr,i as vr,s as yr,k as u,q as n,a as s,y as l,l as g,m as v,r as d,h as r,c as i,z as c,n as wr,b as o,G as a,A as f,H as br,g as p,d as $,B as m}from"../chunks/index.a7566c1a.js";import{H as y}from"../chunks/HeadingLink.20322812.js";import{C as w}from"../chunks/CodeBlock.a090ee9b.js";import{T as Rr}from"../chunks/Toc.c31a36b6.js";function xr(ur){let E,wt,Oe,h,he,C,Ce,B,Be,T,Te,I,Ie,A,Ae,q,qe,j,je,P,Pe,S,Se,N,Ne,x,bt,ge,Rt,xt,ce,kt,Ft,Ue,b,Et,ve,Dt,_t,ye,Ot,ht,we,Ct,Bt,Le,U,He,R,Tt,be,It,At,Re,qt,jt,xe,Pt,St,We,L,Je,H,Ke,W,Ve,J,Ge,K,Qe,V,ze,G,Me,Q,Ye,z,Xe,M,Ze,Y,et,X,tt,Z,rt,ee,ot,te,at,re,st,oe,it,ae,nt,se,lt,ie,dt,k,Nt,ke,Ut,Lt,Fe,Ht,Wt,ct,F,Jt,Ee,Kt,Vt,De,Gt,Qt,ft,fe,zt,pt,ne,$t,le,mt,D,Mt,_e,Yt,Xt,ut,pe,Zt,gt,de,vt;return h=new Rr({}),C=new y({props:{title:"Get/Set record fields"}}),B=new w({props:{language:"javascript",content:`
        // export the public safe record fields as map[string]any
        record.publicExport()

        // returns a new model copy populated with the original/intial record data
        // (could be useful if you want to compare old and new field values)
        record.originalCopy()

        // returns a copy of the current record model populated only
        // with its latest data state and everything else reset to the defaults
        record.cleanCopy()

        // set the value of a single record field
        record.set("someField", 123)

        // bulk set fields from a map
        record.load(data)

        // retrieve a single record field value
        record.get("someField")            // -> as any
        record.getBool("someField")        // -> as bool
        record.getString("someField")      // -> as string
        record.getInt("someField")         // -> as int
        record.getFloat("someField")       // -> as float64
        record.getTime("someField")        // -> as time.Time
        record.getDateTime("someField")    // -> as types.DateTime
        record.getStringSlice("someField") // -> as []string

        // unmarshal a single json field value into the provided result
        const result = new DynamicModel({ ... })
        record.unmarshalJSONField("someJsonField", result)

        // retrieve a single or multiple expanded data
        record.expandedOne("author")     // -> as null|Record
        record.expandedAll("categories") // -> as []Record

        // auth records only
        // ---
        record.setPassword("123456")
        record.validatePassword("123456")
        record.passwordHash()
        // ---
        record.username()
        record.setUsername("john.doe")
        // ---
        record.email()
        record.setEmail("test@example.com")
        // ---
        record.emailVisibility()
        record.setEmailVisibility(false)
        // ---
        record.verified()
        record.setVerified(false)
        // ---
        record.tokenKey()
        record.setTokenKey("ABCD123")
        record.refreshTokenKey() // sets autogenerated TokenKey
        // ---
        record.lastResetSentAt()
        record.setLastResetSentAt(new DateTime())
        // ---
        record.lastVerificationSentAt()
        record.setLastVerificationSentAt(new DateTime())
    `}}),T=new y({props:{title:"Fetch records"}}),I=new y({props:{title:"Fetch single record",tag:"h5"}}),A=new w({props:{language:"javascript",content:`
        // retrieve a single "articles" collection record by its id
        const record = $app.dao().findRecordById("articles", "RECORD_ID")

        // retrieve a single "articles" collection record by a single key-value pair
        const record = $app.dao().findFirstRecordByData("articles", "slug", "test")

        // retrieve a single "articles" collection record by a string filter expression
        // (use "{:placeholder}" to safely bind untrusted user input parameters)
        const record = $app.dao().findFirstRecordByFilter(
            "articles", "status = 'public' && category = {:category}",
            { category: "news" },
        )
    `}}),q=new y({props:{title:"Fetch multiple records",tag:"h5"}}),j=new w({props:{language:"javascript",content:`
        // retrieve multiple "articles" collection records by their ids
        const records = $app.dao().findRecordsByIds("articles", ["RECORD_ID1", "RECORD_ID2"])

        // retrieve multiple "articles" collection records by a custom dbx expression(s)
        // (for all avalaible expressions, please check the Database guide)
        const records = $app.dao().findRecordsByExpr("articles",
            $dbx.exp("LOWER(username) = {:username}", { "username": "John.Doe" }),
            $dbx.hashExp({ status: "pending" })
        )

        // retrieve multiple "articles" collection records by a string filter expression
        // (use "{:placeholder}" to safely bind untrusted user input parameters)
        const records = $app.dao().findRecordsByFilter(
            "articles",                                    // collection
            "status = 'public' && category = {:category}", // filter
            "-publised",                                   // sort
            10,                                            // limit
            0,                                             // offset
            { category: "news" },                          // optional filter params
        )
    `}}),P=new y({props:{title:"Fetch auth records",tag:"h5"}}),S=new w({props:{language:"javascript",content:`
        // retrieve a single auth collection record by its email
        const user = $app.dao().findAuthRecordByEmail("users", "test@example.com")

        // retrieve a single auth collection record by its username (case insensitive)
        const user = $app.dao().findAuthRecordByUsername("users", "John.Doe")

        // retrieve a single auth collection record by its JWT (auth, password reset, etc.)
        const user = $app.dao().findAuthRecordByToken("YOUR_TOKEN", $app.settings().recordAuthToken.secret)
    `}}),N=new y({props:{title:"Custom record query",tag:"h5"}}),U=new w({props:{language:"javascript",content:`
        function findTopArticle() {
            const record = new Record();

            $app.dao().recordQuery("articles")
                .andWhere($dbx.hashExp({ "status": "active" }))
                .orderBy("rank ASC")
                .limit(1)
                .one(record)

            return record
        }

        const article = findTopArticle()
    `}}),L=new w({props:{language:"javascript",content:`
        // the below is identical to
        // dao.findRecordsByFilter("articles", "status = 'active'", '-published', 10)
        // but allows more advanced use cases and filtering (aggregations, subqueries, etc.)
        function findLatestArticles() {
            const records = arrayOf(new Record);

            $app.dao().recordQuery("articles")
                .andWhere($dbx.hashExp({ "status": "active" }))
                .orderBy("published DESC")
                .limit(10)
                .all(records)

            return records
        }

        const articles = findLatestArticles()
    `}}),H=new y({props:{title:"Create new record"}}),W=new y({props:{title:"Create new record WITHOUT data validations",tag:"h5"}}),J=new w({props:{language:"javascript",content:`
        const collection = $app.dao().findCollectionByNameOrId("articles")

        const record = new Record(collection, {
            // bulk load the record data during initialization
            "title": "Lorem ipsum",
            "active": true
        })

        // or load individual fields separately
        record.set("someOtherField", 123)

        $app.dao().saveRecord(record)
    `}}),K=new y({props:{title:"Create new record WITH data validations",tag:"h5"}}),V=new w({props:{language:"javascript",content:`
        const collection = $app.dao().findCollectionByNameOrId("articles")

        const record = new Record(collection)

        const form = new RecordUpsertForm($app, record)

        // or form.loadRequest(request, "")
        form.loadData({
            "title":          "Lorem ipsum",
            "active":         true,
            "someOtherField": 123,
        })

        // manually upload file(s)
        const f1 = $filesystem.fileFromPath("/path/to/file1")
        const f2 = $filesystem.fileFromPath("/path/to/file2")
        form.addFiles("yourFileField1", f1, f2)

        // or mark file(s) for deletion
        form.removeFiles("yourFileField2", "demo_xzihx0w.png")

        // validate and submit (internally it calls $app.dao().saveRecord(record) in a transaction)
        form.submit()
    `}}),G=new y({props:{title:"Intercept record before create API hook",tag:"h5"}}),Q=new w({props:{language:"javascript",content:`
        onRecordBeforeCreateRequest((e) => {
            if (e.httpContext.get("admin")) {
                return null // ignore for admins
            }

            // overwrite the submitted "active" field value to false
            e.record.set("active", false)

            // or you can also prevent the create event by returning an error, eg.:
            if (e.record.get("status") != "pending") {
                throw new BadRequestError("status must be pending")
            }
        }, "articles")
    `}}),z=new y({props:{title:"Update existing record"}}),M=new y({props:{title:"Update record WITHOUT data validations",tag:"h5"}}),Y=new w({props:{language:"javascript",content:`
        const record = $app.dao().findRecordById("articles", "RECORD_ID")

        // set individual fields
        // or bulk load with record.load({...})
        record.set("title", "Lorem ipsum")
        record.set("active", true)
        record.set("someOtherField", 123)

        $app.dao().saveRecord(record)
    `}}),X=new y({props:{title:"Update record WITH data validations",tag:"h5"}}),Z=new w({props:{language:"javascript",content:`
        const record = $app.dao().findRecordById("articles", "RECORD_ID")

        const form = new RecordUpsertForm($app, record)

        // or form.loadRequest(request, "")
        form.loadData({
            "title":          "Lorem ipsum",
            "active":         true,
            "someOtherField": 123,
        })

        // validate and submit (internally it calls $app.dao().saveRecord(record) in a transaction)
        form.submit();
    `}}),ee=new y({props:{title:"Intercept record before update API hook",tag:"h5"}}),te=new w({props:{language:"javascript",content:`
        onRecordBeforeUpdateRequest((e) => {
            if (e.httpContext.get("admin")) {
                return null // ignore for admins
            }

            // overwrite the submitted "active" field value to false
            e.record.set("active", false)

            // or you can also prevent the create event by returning an error, eg.:
            if (e.record.get("status") != "pending") {
                throw new BadRequestError("status must be pending")
            }
        }, "articles")
    `}}),re=new y({props:{title:"Delete record"}}),oe=new w({props:{language:"javascript",content:`
        const record = $app.dao().findRecordById("articles", "RECORD_ID")

        $app.dao().deleteRecord(record)
    `}}),ae=new y({props:{title:"Transaction"}}),se=new w({props:{language:"javascript",content:`
        const titles = ["title1", "title2", "title3"]

        const collection = $app.dao().findCollectionByNameOrId("articles")

        $app.dao().runInTransaction((txDao) => {
            // create new record for each title
            for (let title of titles) {
                const record = new Record(collection)

                record.set("title", title)

                txDao.saveRecord(record)
            }
        })
    `}}),ie=new y({props:{title:"Programmatically expanding relations"}}),ne=new w({props:{language:"javascript",content:`
        const record = $app.dao().findFirstRecordByData("articles", "slug", "lorem-ipsum")

        // expand the "author" and "categories" relations
        $app.dao().expandRecord(record, ["author", "categories"], null)

        // print the expanded records
        console.log(record.expandedOne("author"))
        console.log(record.expandedAll("categories"))
    `}}),le=new y({props:{title:"Check if record can be accessed"}}),de=new w({props:{language:"javascript",content:`
        // allow access to the article with the specified slug
        // only if the current client request satisfy the articles view rule
        routerAdd("get", "/articles/:slug", (c) => {
            const info = $apis.requestInfo(c)

            const slug = c.pathParam("slug")

            const record = $app.dao().findFirstRecordByData("articles", "slug", slug)

            const canAccess = $app.dao().canAccessRecord(record, info, record.collection().viewRule)
            if (!canAccess) {
                throw new ForbiddenError()
            }

            return c.json(200, record)
        })
    `}}),{c(){E=u("p"),wt=n(`The most common task when extending PocketBase probably would be querying and operating with your
    collection records.`),Oe=s(),l(h.$$.fragment),he=s(),l(C.$$.fragment),Ce=s(),l(B.$$.fragment),Be=s(),l(T.$$.fragment),Te=s(),l(I.$$.fragment),Ie=s(),l(A.$$.fragment),Ae=s(),l(q.$$.fragment),qe=s(),l(j.$$.fragment),je=s(),l(P.$$.fragment),Pe=s(),l(S.$$.fragment),Se=s(),l(N.$$.fragment),Ne=s(),x=u("p"),bt=n(`In addition to the above read and write helpers, you can also create custom Record model queries using
    `),ge=u("code"),Rt=n("Dao.recordQuery(collection)"),xt=n(`
    method. It returns a DB builder that can be used with the same methods described in the
    `),ce=u("a"),kt=n("Database guide"),Ft=n("."),Ue=s(),b=u("p"),Et=n("For retrieving a "),ve=u("strong"),Dt=n("single"),_t=n(" Record model with the "),ye=u("code"),Ot=n("one()"),ht=n(` executor, you can use a
    blank `),we=u("code"),Ct=n("new Record()"),Bt=n(" model to populate the result in."),Le=s(),l(U.$$.fragment),He=s(),R=u("p"),Tt=n("For retrieving "),be=u("strong"),It=n("multiple"),At=n(" Record models with the "),Re=u("code"),qt=n("all()"),jt=n(` executor, you can use
    `),xe=u("code"),Pt=n("arrayOf(new Record)"),St=n(`
    to create an array placeholder in which to populate the resolved DB result.`),We=s(),l(L.$$.fragment),Je=s(),l(H.$$.fragment),Ke=s(),l(W.$$.fragment),Ve=s(),l(J.$$.fragment),Ge=s(),l(K.$$.fragment),Qe=s(),l(V.$$.fragment),ze=s(),l(G.$$.fragment),Me=s(),l(Q.$$.fragment),Ye=s(),l(z.$$.fragment),Xe=s(),l(M.$$.fragment),Ze=s(),l(Y.$$.fragment),et=s(),l(X.$$.fragment),tt=s(),l(Z.$$.fragment),rt=s(),l(ee.$$.fragment),ot=s(),l(te.$$.fragment),at=s(),l(re.$$.fragment),st=s(),l(oe.$$.fragment),it=s(),l(ae.$$.fragment),nt=s(),l(se.$$.fragment),lt=s(),l(ie.$$.fragment),dt=s(),k=u("p"),Nt=n(`To expand record relations programmatically you can use the
    `),ke=u("code"),Ut=n("$app.dao().expandRecord(record, expands, customFetchFunc)"),Lt=n(` or
    `),Fe=u("code"),Ht=n("$app.dao().expandRecords(records, expands, customFetchFunc)"),Wt=n(`
    methods.`),ct=s(),F=u("p"),Jt=n(`Once loaded, you can access the expanded relations via
    `),Ee=u("code"),Kt=n("record.expandedOne(relName)"),Vt=n(` or
    `),De=u("code"),Gt=n("record.expandedAll(relName)"),Qt=n(" methods."),ft=s(),fe=u("p"),zt=n("For example:"),pt=s(),l(ne.$$.fragment),$t=s(),l(le.$$.fragment),mt=s(),D=u("p"),Mt=n(`To check whether a custom client request or user can access a single record, you can use the
    `),_e=u("code"),Yt=n("$app.dao().canAccessRecord(record, requestInfo, rule)"),Xt=n(" method."),ut=s(),pe=u("p"),Zt=n("For example:"),gt=s(),l(de.$$.fragment),this.h()},l(e){E=g(e,"P",{});var t=v(E);wt=d(t,`The most common task when extending PocketBase probably would be querying and operating with your
    collection records.`),t.forEach(r),Oe=i(e),c(h.$$.fragment,e),he=i(e),c(C.$$.fragment,e),Ce=i(e),c(B.$$.fragment,e),Be=i(e),c(T.$$.fragment,e),Te=i(e),c(I.$$.fragment,e),Ie=i(e),c(A.$$.fragment,e),Ae=i(e),c(q.$$.fragment,e),qe=i(e),c(j.$$.fragment,e),je=i(e),c(P.$$.fragment,e),Pe=i(e),c(S.$$.fragment,e),Se=i(e),c(N.$$.fragment,e),Ne=i(e),x=g(e,"P",{});var $e=v(x);bt=d($e,`In addition to the above read and write helpers, you can also create custom Record model queries using
    `),ge=g($e,"CODE",{});var er=v(ge);Rt=d(er,"Dao.recordQuery(collection)"),er.forEach(r),xt=d($e,`
    method. It returns a DB builder that can be used with the same methods described in the
    `),ce=g($e,"A",{href:!0});var tr=v(ce);kt=d(tr,"Database guide"),tr.forEach(r),Ft=d($e,"."),$e.forEach(r),Ue=i(e),b=g(e,"P",{});var _=v(b);Et=d(_,"For retrieving a "),ve=g(_,"STRONG",{});var rr=v(ve);Dt=d(rr,"single"),rr.forEach(r),_t=d(_," Record model with the "),ye=g(_,"CODE",{});var or=v(ye);Ot=d(or,"one()"),or.forEach(r),ht=d(_,` executor, you can use a
    blank `),we=g(_,"CODE",{});var ar=v(we);Ct=d(ar,"new Record()"),ar.forEach(r),Bt=d(_," model to populate the result in."),_.forEach(r),Le=i(e),c(U.$$.fragment,e),He=i(e),R=g(e,"P",{});var O=v(R);Tt=d(O,"For retrieving "),be=g(O,"STRONG",{});var sr=v(be);It=d(sr,"multiple"),sr.forEach(r),At=d(O," Record models with the "),Re=g(O,"CODE",{});var ir=v(Re);qt=d(ir,"all()"),ir.forEach(r),jt=d(O,` executor, you can use
    `),xe=g(O,"CODE",{});var nr=v(xe);Pt=d(nr,"arrayOf(new Record)"),nr.forEach(r),St=d(O,`
    to create an array placeholder in which to populate the resolved DB result.`),O.forEach(r),We=i(e),c(L.$$.fragment,e),Je=i(e),c(H.$$.fragment,e),Ke=i(e),c(W.$$.fragment,e),Ve=i(e),c(J.$$.fragment,e),Ge=i(e),c(K.$$.fragment,e),Qe=i(e),c(V.$$.fragment,e),ze=i(e),c(G.$$.fragment,e),Me=i(e),c(Q.$$.fragment,e),Ye=i(e),c(z.$$.fragment,e),Xe=i(e),c(M.$$.fragment,e),Ze=i(e),c(Y.$$.fragment,e),et=i(e),c(X.$$.fragment,e),tt=i(e),c(Z.$$.fragment,e),rt=i(e),c(ee.$$.fragment,e),ot=i(e),c(te.$$.fragment,e),at=i(e),c(re.$$.fragment,e),st=i(e),c(oe.$$.fragment,e),it=i(e),c(ae.$$.fragment,e),nt=i(e),c(se.$$.fragment,e),lt=i(e),c(ie.$$.fragment,e),dt=i(e),k=g(e,"P",{});var me=v(k);Nt=d(me,`To expand record relations programmatically you can use the
    `),ke=g(me,"CODE",{});var lr=v(ke);Ut=d(lr,"$app.dao().expandRecord(record, expands, customFetchFunc)"),lr.forEach(r),Lt=d(me,` or
    `),Fe=g(me,"CODE",{});var dr=v(Fe);Ht=d(dr,"$app.dao().expandRecords(records, expands, customFetchFunc)"),dr.forEach(r),Wt=d(me,`
    methods.`),me.forEach(r),ct=i(e),F=g(e,"P",{});var ue=v(F);Jt=d(ue,`Once loaded, you can access the expanded relations via
    `),Ee=g(ue,"CODE",{});var cr=v(Ee);Kt=d(cr,"record.expandedOne(relName)"),cr.forEach(r),Vt=d(ue,` or
    `),De=g(ue,"CODE",{});var fr=v(De);Gt=d(fr,"record.expandedAll(relName)"),fr.forEach(r),Qt=d(ue," methods."),ue.forEach(r),ft=i(e),fe=g(e,"P",{});var pr=v(fe);zt=d(pr,"For example:"),pr.forEach(r),pt=i(e),c(ne.$$.fragment,e),$t=i(e),c(le.$$.fragment,e),mt=i(e),D=g(e,"P",{});var yt=v(D);Mt=d(yt,`To check whether a custom client request or user can access a single record, you can use the
    `),_e=g(yt,"CODE",{});var $r=v(_e);Yt=d($r,"$app.dao().canAccessRecord(record, requestInfo, rule)"),$r.forEach(r),Xt=d(yt," method."),yt.forEach(r),ut=i(e),pe=g(e,"P",{});var mr=v(pe);Zt=d(mr,"For example:"),mr.forEach(r),gt=i(e),c(de.$$.fragment,e),this.h()},h(){wr(ce,"href","/docs/js-database")},m(e,t){o(e,E,t),a(E,wt),o(e,Oe,t),f(h,e,t),o(e,he,t),f(C,e,t),o(e,Ce,t),f(B,e,t),o(e,Be,t),f(T,e,t),o(e,Te,t),f(I,e,t),o(e,Ie,t),f(A,e,t),o(e,Ae,t),f(q,e,t),o(e,qe,t),f(j,e,t),o(e,je,t),f(P,e,t),o(e,Pe,t),f(S,e,t),o(e,Se,t),f(N,e,t),o(e,Ne,t),o(e,x,t),a(x,bt),a(x,ge),a(ge,Rt),a(x,xt),a(x,ce),a(ce,kt),a(x,Ft),o(e,Ue,t),o(e,b,t),a(b,Et),a(b,ve),a(ve,Dt),a(b,_t),a(b,ye),a(ye,Ot),a(b,ht),a(b,we),a(we,Ct),a(b,Bt),o(e,Le,t),f(U,e,t),o(e,He,t),o(e,R,t),a(R,Tt),a(R,be),a(be,It),a(R,At),a(R,Re),a(Re,qt),a(R,jt),a(R,xe),a(xe,Pt),a(R,St),o(e,We,t),f(L,e,t),o(e,Je,t),f(H,e,t),o(e,Ke,t),f(W,e,t),o(e,Ve,t),f(J,e,t),o(e,Ge,t),f(K,e,t),o(e,Qe,t),f(V,e,t),o(e,ze,t),f(G,e,t),o(e,Me,t),f(Q,e,t),o(e,Ye,t),f(z,e,t),o(e,Xe,t),f(M,e,t),o(e,Ze,t),f(Y,e,t),o(e,et,t),f(X,e,t),o(e,tt,t),f(Z,e,t),o(e,rt,t),f(ee,e,t),o(e,ot,t),f(te,e,t),o(e,at,t),f(re,e,t),o(e,st,t),f(oe,e,t),o(e,it,t),f(ae,e,t),o(e,nt,t),f(se,e,t),o(e,lt,t),f(ie,e,t),o(e,dt,t),o(e,k,t),a(k,Nt),a(k,ke),a(ke,Ut),a(k,Lt),a(k,Fe),a(Fe,Ht),a(k,Wt),o(e,ct,t),o(e,F,t),a(F,Jt),a(F,Ee),a(Ee,Kt),a(F,Vt),a(F,De),a(De,Gt),a(F,Qt),o(e,ft,t),o(e,fe,t),a(fe,zt),o(e,pt,t),f(ne,e,t),o(e,$t,t),f(le,e,t),o(e,mt,t),o(e,D,t),a(D,Mt),a(D,_e),a(_e,Yt),a(D,Xt),o(e,ut,t),o(e,pe,t),a(pe,Zt),o(e,gt,t),f(de,e,t),vt=!0},p:br,i(e){vt||(p(h.$$.fragment,e),p(C.$$.fragment,e),p(B.$$.fragment,e),p(T.$$.fragment,e),p(I.$$.fragment,e),p(A.$$.fragment,e),p(q.$$.fragment,e),p(j.$$.fragment,e),p(P.$$.fragment,e),p(S.$$.fragment,e),p(N.$$.fragment,e),p(U.$$.fragment,e),p(L.$$.fragment,e),p(H.$$.fragment,e),p(W.$$.fragment,e),p(J.$$.fragment,e),p(K.$$.fragment,e),p(V.$$.fragment,e),p(G.$$.fragment,e),p(Q.$$.fragment,e),p(z.$$.fragment,e),p(M.$$.fragment,e),p(Y.$$.fragment,e),p(X.$$.fragment,e),p(Z.$$.fragment,e),p(ee.$$.fragment,e),p(te.$$.fragment,e),p(re.$$.fragment,e),p(oe.$$.fragment,e),p(ae.$$.fragment,e),p(se.$$.fragment,e),p(ie.$$.fragment,e),p(ne.$$.fragment,e),p(le.$$.fragment,e),p(de.$$.fragment,e),vt=!0)},o(e){$(h.$$.fragment,e),$(C.$$.fragment,e),$(B.$$.fragment,e),$(T.$$.fragment,e),$(I.$$.fragment,e),$(A.$$.fragment,e),$(q.$$.fragment,e),$(j.$$.fragment,e),$(P.$$.fragment,e),$(S.$$.fragment,e),$(N.$$.fragment,e),$(U.$$.fragment,e),$(L.$$.fragment,e),$(H.$$.fragment,e),$(W.$$.fragment,e),$(J.$$.fragment,e),$(K.$$.fragment,e),$(V.$$.fragment,e),$(G.$$.fragment,e),$(Q.$$.fragment,e),$(z.$$.fragment,e),$(M.$$.fragment,e),$(Y.$$.fragment,e),$(X.$$.fragment,e),$(Z.$$.fragment,e),$(ee.$$.fragment,e),$(te.$$.fragment,e),$(re.$$.fragment,e),$(oe.$$.fragment,e),$(ae.$$.fragment,e),$(se.$$.fragment,e),$(ie.$$.fragment,e),$(ne.$$.fragment,e),$(le.$$.fragment,e),$(de.$$.fragment,e),vt=!1},d(e){e&&r(E),e&&r(Oe),m(h,e),e&&r(he),m(C,e),e&&r(Ce),m(B,e),e&&r(Be),m(T,e),e&&r(Te),m(I,e),e&&r(Ie),m(A,e),e&&r(Ae),m(q,e),e&&r(qe),m(j,e),e&&r(je),m(P,e),e&&r(Pe),m(S,e),e&&r(Se),m(N,e),e&&r(Ne),e&&r(x),e&&r(Ue),e&&r(b),e&&r(Le),m(U,e),e&&r(He),e&&r(R),e&&r(We),m(L,e),e&&r(Je),m(H,e),e&&r(Ke),m(W,e),e&&r(Ve),m(J,e),e&&r(Ge),m(K,e),e&&r(Qe),m(V,e),e&&r(ze),m(G,e),e&&r(Me),m(Q,e),e&&r(Ye),m(z,e),e&&r(Xe),m(M,e),e&&r(Ze),m(Y,e),e&&r(et),m(X,e),e&&r(tt),m(Z,e),e&&r(rt),m(ee,e),e&&r(ot),m(te,e),e&&r(at),m(re,e),e&&r(st),m(oe,e),e&&r(it),m(ae,e),e&&r(nt),m(se,e),e&&r(lt),m(ie,e),e&&r(dt),e&&r(k),e&&r(ct),e&&r(F),e&&r(ft),e&&r(fe),e&&r(pt),m(ne,e),e&&r($t),m(le,e),e&&r(mt),e&&r(D),e&&r(ut),e&&r(pe),e&&r(gt),m(de,e)}}}class _r extends gr{constructor(E){super(),vr(this,E,null,xr,yr,{})}}export{_r as component};
